---
title: "Memoria de Series Temporales"
author: "Enrique Sayas Bailach y Carlos Gila Blanco"
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introducción

Los dos datasets utilizados han sido descargados desde Kaggle.

El utilizado para la serie temporal con tendencia es [annual_gold_rate](https://www.kaggle.com/datasets/hemil26/gold-rates-1985-jan-2022), que muestra el valor anual del oro desde 1980 hasta 2022 en Dirham de los Emiratos Árabes Unidos.

Por otra parte, el dataset utilizado para la serie temporal con tendencia y estacionalidad es [HospitalityEmployees](https://www.kaggle.com/datasets/gabrielsantello/hospitality-employees-time-series-dataset/data), que muestra el número de empleados en la hostelería en California desde enero de 1990 hasta diciembre de 2018.

# Carga de librerías

```{r}
library(forecast)
library(readr)
library(lubridate)
library(dplyr)
library(ggplot2)
```

# Serie temporal con tendencia

### Importación de los datos

```{r}
gold <- read_csv("Datos/annual_gold_rate.csv", 
    col_types = cols(Date = col_date(format = "%Y-%m-%d")))
```

### Creación de la serie temporal

```{r}
attach(gold)
gold_ts <- ts(AED,start=c(1980),frequency=1)
plot(gold_ts, ylab = "Gold Value (AED)")
```

Se puede observar que hay una tendencia.

## Serie temporal con tendencia

En base a la evolución temporal del valor del oro, se puede observar que existe una tendencia pero no una estacionalidad.

Por tanto, el mejor modelo de suavizado exponencial será el modelo de Host.

Las ecuaciones de observación y actualización del modelo son las siguientes:

$$
\hat{x}_t=L_{t-1} + T_{t-1} +\epsilon_t, \epsilon_t \sim N(0,\sigma^2)
$$
$$
L_t = \alpha \cdot x_t + (1-\alpha) \cdot (L_{t-1}+T_{t-1})
$$
$$
T_t = \beta \cdot (L_t-L_{t-1}) + (1-\beta) \cdot T_{t-1}
$$

Ecuación de predicción:

$$
\hat{x}_{n+k} = L_n + k \cdot T_{n}
$$

### Creación del modelo

```{r}
gold_holt <- HoltWinters(gold_ts, gamma = FALSE)
```

### Visualización de los coeficientes y los parámetros

```{r}
gold_holt$coefficients
```

```{r}
gold_holt$alpha
```

```{r}
gold_holt$beta
```

Al ser $\alpha = 1$, sólo se tendrá en cuenta el valor anterior para calcular el nivel del valor siguiente.

A partir de los coeficientes obtenidos calculamos las ecuaciones de actualización:

$$
L_t = x_t
$$
$$
T_t = 0.6672362 \cdot (L_t-L_{t-1}) + (1-0.6672362) \cdot T_{t-1}
$$

Y la ecuación de predicción:

$$
\hat{x}_{n+k} = 6611.71 + k \cdot 141.3085
$$

### Cálculo de la bondad del ajuste

```{r}
fitval_gold <- fitted(gold_holt)
tail(fitval_gold, 10)
```

```{r}
rmse <- sqrt(mean((gold_ts - fitval_gold[,1])^2))
rmse
```

```{r}
mape <- 100*mean(abs(gold_ts-fitval_gold[,1])/gold_ts)
mape
```

A partir del MAPE se puede concluir que se tiene un error medio del 9.89%.

### Representación de la serie real frente a la serie ajustada

```{r}
plot(gold_holt)
```

En el gráfico se puede observar el error medio del 9.89% respecto a la serie original.

### Predicción para h=2

```{r}
pred_gold <- predict(gold_holt,2)
```

### Representación de la predicción junto a la serie

```{r}
pred <- predict(gold_holt,n.ahead=4,prediction.interval=TRUE,level=0.95) 

plot(gold_holt, pred)
```

# Serie temporal con tendencia + estacionalidad

### Importación y Adecuación de la serie

```{r}
HospitalityEmployees <- read_csv("Datos/HospitalityEmployees.csv")
HospitalityEmployees$Date <- as.Date(HospitalityEmployees$Date, format = "%m/%d/%Y")
HospitalityEmployees$Employees <- floor(HospitalityEmployees$Employees)
```

### Representación de la serie temporal

```{r}
attach(HospitalityEmployees)
HospitalityEmployees_ts <- ts(Employees,start=c(1990,1),end=c(2018,12),frequency=12)
HospEmp2010_ts <- window(HospitalityEmployees_ts, start = c(2010,1))
plot(HospEmp2010_ts, ylab = "Hospitality Employees")
```

### Descripción de la serie

```{r}
plot(decompose(HospEmp2010_ts, type="additive"))
```

En base a la evolución temporal del número de empleados en la hostelería, se puede observar que existe una tendencia y una estacionalidad.

### Comparación de los modelos

Modelo Holt-Winters con estacionalidad aditiva

```{r}
emp_ad <- HoltWinters(HospEmp2010_ts, seasonal = "additive")
fit_emp_ad <- fitted(emp_ad)

#RMSE
rmse_ad <- sqrt(mean((HospEmp2010_ts - fit_emp_ad[,1])^2))
rmse_ad

#MAPE
mape_ad <- 100*mean(abs(HospEmp2010_ts-fit_emp_ad[,1])/HospEmp2010_ts)
mape_ad
```

Modelo Holt-Winters con estacionalidad multiplicativa

```{r}
emp_mult <- HoltWinters(HospEmp2010_ts, seasonal = "multiplicative")
fit_emp_mult <- fitted(emp_mult)

#RMSE
rmse_mult <- sqrt(mean((HospEmp2010_ts - fit_emp_mult[,1])^2))
rmse_mult

#MAPE
mape_mult <- 100*mean(abs(HospEmp2010_ts-fit_emp_mult[,1])/HospEmp2010_ts)
mape_mult
```

Comparación entre los modelos Holt-Winters aditivo y multiplicativo en base a los errores RMSE y MAPE

$$
\begin{tabular}{| c | c | c |}
\hline
    Holt-Winters & RMSE & MAPE \\ \hline
    Additive & 6.192158 & 0.2809599\\ \hline
    Multiplicative & 5.668459 & 0.2562788 \\ \hline
\end{tabular} 
$$
El mejor modelo de suavizado exponencial será el modelo de Host-Winters con estacionalidad aditiva pues la diferencia en el RMSE entre ambos modelos es muy pequeña, siendo más fácil la implementación del modelo con estacionalidad aditiva.

Las ecuaciones de observación y actualización del modelo son las siguientes:

$$
\hat{x}_t = L_{t-1} + T_{t-1} + S_{t-c} +\epsilon_t, \epsilon_t \sim N(0,\sigma^2)
$$

$$
L_t = \alpha \cdot (x_{t}-S_{t-c}) + (1-\alpha) \cdot (L_{t-1} + T_{t-1})
$$
$$
T_t = \beta \cdot (L_t - L_{t-1}) + (1 - \beta) \cdot T_{t-1}
$$

$$
S_t = \gamma \cdot (x_t - L_t) + (1 - \gamma) \cdot S_{t-c}
$$

Y la ecuación de predicción:

$$
\hat{x}_{n+k} = L_n + k\cdot T_n + S_{n+k-c}
$$

### Creación del modelo

```{r}
emp_fit <- HoltWinters(HospEmp2010_ts, seasonal = "additive")
```

### Visualización de los coeficientes y los parámetros

```{r}
emp_fit$coefficients
```

```{r}
emp_fit$alpha
```

```{r}
emp_fit$beta
```

```{r}
emp_fit$gamma
```

Al ser $\beta = 0.055$ la tendencia es constante y como $\gamma = 1$, la estacionalidad la calculará a través de la diferencia entre el valor de $x_t$ y $L_t$.

A partir de los coeficientes obtenidos calculamos las ecuaciones de actualización:

$$
L_t = 0.6583277 \cdot (x_t - S_{t-12}) + (1-0.6583277) \cdot(L_{t-1} + T_{t-1})
$$
$$
T_t = 0.05505944 \cdot (L_t-L_{t-1}) + (1-0.05505944) \cdot T_{t-1}
$$
$$
S_t = x_t - L_t
$$

Y la ecuación de predicción

$$
\hat{x}_{n+k} = 2009.266255 + k \cdot 4.174587 + S_{n+k-12}
$$

### Cálculo de la bondad del ajuste

```{r}
fitval_emp <- fitted(emp_fit)
tail(fitval_emp, 10)
```


### Representación de la serie real frente a la serie ajustada

```{r}
plot(emp_fit)
```

### Predicción para h=c

```{r}
pred_hosp <- predict(emp_fit,12)
```

### Representación de la predicción junto a la serie

```{r}
pred <- predict(emp_fit,n.ahead=12,prediction.interval=TRUE,level=0.95) 

plot(emp_fit, pred)
```
